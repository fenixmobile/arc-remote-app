// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: remotemessage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// remotemessage.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Remote_RemoteKeyCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case keycodeUnknown // = 0
  case keycodeSoftLeft // = 1
  case keycodeSoftRight // = 2
  case keycodeHome // = 3
  case keycodeBack // = 4
  case keycodeCall // = 5
  case keycodeEndcall // = 6
  case keycode0 // = 7
  case keycode1 // = 8
  case keycode2 // = 9
  case keycode3 // = 10
  case keycode4 // = 11
  case keycode5 // = 12
  case keycode6 // = 13
  case keycode7 // = 14
  case keycode8 // = 15
  case keycode9 // = 16
  case keycodeStar // = 17
  case keycodePound // = 18
  case keycodeDpadUp // = 19
  case keycodeDpadDown // = 20
  case keycodeDpadLeft // = 21
  case keycodeDpadRight // = 22
  case keycodeDpadCenter // = 23
  case keycodeVolumeUp // = 24
  case keycodeVolumeDown // = 25
  case keycodePower // = 26
  case keycodeCamera // = 27
  case keycodeClear // = 28
  case keycodeA // = 29
  case keycodeB // = 30
  case keycodeC // = 31
  case keycodeD // = 32
  case keycodeE // = 33
  case keycodeF // = 34
  case keycodeG // = 35
  case keycodeH // = 36
  case keycodeI // = 37
  case keycodeJ // = 38
  case keycodeK // = 39
  case keycodeL // = 40
  case keycodeM // = 41
  case keycodeN // = 42
  case keycodeO // = 43
  case keycodeP // = 44
  case keycodeQ // = 45
  case keycodeR // = 46
  case keycodeS // = 47
  case keycodeT // = 48
  case keycodeU // = 49
  case keycodeV // = 50
  case keycodeW // = 51
  case keycodeX // = 52
  case keycodeY // = 53
  case keycodeZ // = 54
  case keycodeComma // = 55
  case keycodePeriod // = 56
  case keycodeAltLeft // = 57
  case keycodeAltRight // = 58
  case keycodeShiftLeft // = 59
  case keycodeShiftRight // = 60
  case keycodeTab // = 61
  case keycodeSpace // = 62
  case keycodeSym // = 63
  case keycodeExplorer // = 64
  case keycodeEnvelope // = 65
  case keycodeEnter // = 66
  case keycodeDel // = 67
  case keycodeGrave // = 68
  case keycodeMinus // = 69
  case keycodeEquals // = 70
  case keycodeLeftBracket // = 71
  case keycodeRightBracket // = 72
  case keycodeBackslash // = 73
  case keycodeSemicolon // = 74
  case keycodeApostrophe // = 75
  case keycodeSlash // = 76
  case keycodeAt // = 77
  case keycodeNum // = 78
  case keycodeHeadsethook // = 79
  case keycodeFocus // = 80
  case keycodePlus // = 81
  case keycodeMenu // = 82
  case keycodeNotification // = 83
  case keycodeSearch // = 84
  case keycodeMediaPlayPause // = 85
  case keycodeMediaStop // = 86
  case keycodeMediaNext // = 87
  case keycodeMediaPrevious // = 88
  case keycodeMediaRewind // = 89
  case keycodeMediaFastForward // = 90
  case keycodeMute // = 91
  case keycodePageUp // = 92
  case keycodePageDown // = 93
  case keycodePictsymbols // = 94
  case keycodeSwitchCharset // = 95
  case keycodeButtonA // = 96
  case keycodeButtonB // = 97
  case keycodeButtonC // = 98
  case keycodeButtonX // = 99
  case keycodeButtonY // = 100
  case keycodeButtonZ // = 101
  case keycodeButtonL1 // = 102
  case keycodeButtonR1 // = 103
  case keycodeButtonL2 // = 104
  case keycodeButtonR2 // = 105
  case keycodeButtonThumbl // = 106
  case keycodeButtonThumbr // = 107
  case keycodeButtonStart // = 108
  case keycodeButtonSelect // = 109
  case keycodeButtonMode // = 110
  case keycodeEscape // = 111
  case keycodeForwardDel // = 112
  case keycodeCtrlLeft // = 113
  case keycodeCtrlRight // = 114
  case keycodeCapsLock // = 115
  case keycodeScrollLock // = 116
  case keycodeMetaLeft // = 117
  case keycodeMetaRight // = 118
  case keycodeFunction // = 119
  case keycodeSysrq // = 120
  case keycodeBreak // = 121
  case keycodeMoveHome // = 122
  case keycodeMoveEnd // = 123
  case keycodeInsert // = 124
  case keycodeForward // = 125
  case keycodeMediaPlay // = 126
  case keycodeMediaPause // = 127
  case keycodeMediaClose // = 128
  case keycodeMediaEject // = 129
  case keycodeMediaRecord // = 130
  case keycodeF1 // = 131
  case keycodeF2 // = 132
  case keycodeF3 // = 133
  case keycodeF4 // = 134
  case keycodeF5 // = 135
  case keycodeF6 // = 136
  case keycodeF7 // = 137
  case keycodeF8 // = 138
  case keycodeF9 // = 139
  case keycodeF10 // = 140
  case keycodeF11 // = 141
  case keycodeF12 // = 142
  case keycodeNumLock // = 143
  case keycodeNumpad0 // = 144
  case keycodeNumpad1 // = 145
  case keycodeNumpad2 // = 146
  case keycodeNumpad3 // = 147
  case keycodeNumpad4 // = 148
  case keycodeNumpad5 // = 149
  case keycodeNumpad6 // = 150
  case keycodeNumpad7 // = 151
  case keycodeNumpad8 // = 152
  case keycodeNumpad9 // = 153
  case keycodeNumpadDivide // = 154
  case keycodeNumpadMultiply // = 155
  case keycodeNumpadSubtract // = 156
  case keycodeNumpadAdd // = 157
  case keycodeNumpadDot // = 158
  case keycodeNumpadComma // = 159
  case keycodeNumpadEnter // = 160
  case keycodeNumpadEquals // = 161
  case keycodeNumpadLeftParen // = 162
  case keycodeNumpadRightParen // = 163
  case keycodeVolumeMute // = 164
  case keycodeInfo // = 165
  case keycodeChannelUp // = 166
  case keycodeChannelDown // = 167
  case keycodeZoomIn // = 168
  case keycodeZoomOut // = 169
  case keycodeTv // = 170
  case keycodeWindow // = 171
  case keycodeGuide // = 172
  case keycodeDvr // = 173
  case keycodeBookmark // = 174
  case keycodeCaptions // = 175
  case keycodeSettings // = 176
  case keycodeTvPower // = 177
  case keycodeTvInput // = 178
  case keycodeStbPower // = 179
  case keycodeStbInput // = 180
  case keycodeAvrPower // = 181
  case keycodeAvrInput // = 182
  case keycodeProgRed // = 183
  case keycodeProgGreen // = 184
  case keycodeProgYellow // = 185
  case keycodeProgBlue // = 186
  case keycodeAppSwitch // = 187
  case keycodeButton1 // = 188
  case keycodeButton2 // = 189
  case keycodeButton3 // = 190
  case keycodeButton4 // = 191
  case keycodeButton5 // = 192
  case keycodeButton6 // = 193
  case keycodeButton7 // = 194
  case keycodeButton8 // = 195
  case keycodeButton9 // = 196
  case keycodeButton10 // = 197
  case keycodeButton11 // = 198
  case keycodeButton12 // = 199
  case keycodeButton13 // = 200
  case keycodeButton14 // = 201
  case keycodeButton15 // = 202
  case keycodeButton16 // = 203
  case keycodeLanguageSwitch // = 204
  case keycodeMannerMode // = 205
  case keycode3DMode // = 206
  case keycodeContacts // = 207
  case keycodeCalendar // = 208
  case keycodeMusic // = 209
  case keycodeCalculator // = 210
  case keycodeZenkakuHankaku // = 211
  case keycodeEisu // = 212
  case keycodeMuhenkan // = 213
  case keycodeHenkan // = 214
  case keycodeKatakanaHiragana // = 215
  case keycodeYen // = 216
  case keycodeRo // = 217
  case keycodeKana // = 218
  case keycodeAssist // = 219
  case keycodeBrightnessDown // = 220
  case keycodeBrightnessUp // = 221
  case keycodeMediaAudioTrack // = 222
  case keycodeSleep // = 223
  case keycodeWakeup // = 224
  case keycodePairing // = 225
  case keycodeMediaTopMenu // = 226
  case keycode11 // = 227
  case keycode12 // = 228
  case keycodeLastChannel // = 229
  case keycodeTvDataService // = 230
  case keycodeVoiceAssist // = 231
  case keycodeTvRadioService // = 232
  case keycodeTvTeletext // = 233
  case keycodeTvNumberEntry // = 234
  case keycodeTvTerrestrialAnalog // = 235
  case keycodeTvTerrestrialDigital // = 236
  case keycodeTvSatellite // = 237
  case keycodeTvSatelliteBs // = 238
  case keycodeTvSatelliteCs // = 239
  case keycodeTvSatelliteService // = 240
  case keycodeTvNetwork // = 241
  case keycodeTvAntennaCable // = 242
  case keycodeTvInputHdmi1 // = 243
  case keycodeTvInputHdmi2 // = 244
  case keycodeTvInputHdmi3 // = 245
  case keycodeTvInputHdmi4 // = 246
  case keycodeTvInputComposite1 // = 247
  case keycodeTvInputComposite2 // = 248
  case keycodeTvInputComponent1 // = 249
  case keycodeTvInputComponent2 // = 250
  case keycodeTvInputVga1 // = 251
  case keycodeTvAudioDescription // = 252
  case keycodeTvAudioDescriptionMixUp // = 253
  case keycodeTvAudioDescriptionMixDown // = 254
  case keycodeTvZoomMode // = 255
  case keycodeTvContentsMenu // = 256
  case keycodeTvMediaContextMenu // = 257
  case keycodeTvTimerProgramming // = 258
  case keycodeHelp // = 259
  case keycodeNavigatePrevious // = 260
  case keycodeNavigateNext // = 261
  case keycodeNavigateIn // = 262
  case keycodeNavigateOut // = 263
  case keycodeStemPrimary // = 264
  case keycodeStem1 // = 265
  case keycodeStem2 // = 266
  case keycodeStem3 // = 267
  case keycodeDpadUpLeft // = 268
  case keycodeDpadDownLeft // = 269
  case keycodeDpadUpRight // = 270
  case keycodeDpadDownRight // = 271
  case keycodeMediaSkipForward // = 272
  case keycodeMediaSkipBackward // = 273
  case keycodeMediaStepForward // = 274
  case keycodeMediaStepBackward // = 275
  case keycodeSoftSleep // = 276
  case keycodeCut // = 277
  case keycodeCopy // = 278
  case keycodePaste // = 279
  case keycodeSystemNavigationUp // = 280
  case keycodeSystemNavigationDown // = 281
  case keycodeSystemNavigationLeft // = 282
  case keycodeSystemNavigationRight // = 283
  case keycodeAllApps // = 284
  case keycodeRefresh // = 285
  case keycodeThumbsUp // = 286
  case keycodeThumbsDown // = 287
  case keycodeProfileSwitch // = 288
  case keycodeVideoApp1 // = 289
  case keycodeVideoApp2 // = 290
  case keycodeVideoApp3 // = 291
  case keycodeVideoApp4 // = 292
  case keycodeVideoApp5 // = 293
  case keycodeVideoApp6 // = 294
  case keycodeVideoApp7 // = 295
  case keycodeVideoApp8 // = 296
  case keycodeFeaturedApp1 // = 297
  case keycodeFeaturedApp2 // = 298
  case keycodeFeaturedApp3 // = 299
  case keycodeFeaturedApp4 // = 300
  case keycodeDemoApp1 // = 301
  case keycodeDemoApp2 // = 302
  case keycodeDemoApp3 // = 303
  case keycodeDemoApp4 // = 304
  case UNRECOGNIZED(Int)

  init() {
    self = .keycodeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keycodeUnknown
    case 1: self = .keycodeSoftLeft
    case 2: self = .keycodeSoftRight
    case 3: self = .keycodeHome
    case 4: self = .keycodeBack
    case 5: self = .keycodeCall
    case 6: self = .keycodeEndcall
    case 7: self = .keycode0
    case 8: self = .keycode1
    case 9: self = .keycode2
    case 10: self = .keycode3
    case 11: self = .keycode4
    case 12: self = .keycode5
    case 13: self = .keycode6
    case 14: self = .keycode7
    case 15: self = .keycode8
    case 16: self = .keycode9
    case 17: self = .keycodeStar
    case 18: self = .keycodePound
    case 19: self = .keycodeDpadUp
    case 20: self = .keycodeDpadDown
    case 21: self = .keycodeDpadLeft
    case 22: self = .keycodeDpadRight
    case 23: self = .keycodeDpadCenter
    case 24: self = .keycodeVolumeUp
    case 25: self = .keycodeVolumeDown
    case 26: self = .keycodePower
    case 27: self = .keycodeCamera
    case 28: self = .keycodeClear
    case 29: self = .keycodeA
    case 30: self = .keycodeB
    case 31: self = .keycodeC
    case 32: self = .keycodeD
    case 33: self = .keycodeE
    case 34: self = .keycodeF
    case 35: self = .keycodeG
    case 36: self = .keycodeH
    case 37: self = .keycodeI
    case 38: self = .keycodeJ
    case 39: self = .keycodeK
    case 40: self = .keycodeL
    case 41: self = .keycodeM
    case 42: self = .keycodeN
    case 43: self = .keycodeO
    case 44: self = .keycodeP
    case 45: self = .keycodeQ
    case 46: self = .keycodeR
    case 47: self = .keycodeS
    case 48: self = .keycodeT
    case 49: self = .keycodeU
    case 50: self = .keycodeV
    case 51: self = .keycodeW
    case 52: self = .keycodeX
    case 53: self = .keycodeY
    case 54: self = .keycodeZ
    case 55: self = .keycodeComma
    case 56: self = .keycodePeriod
    case 57: self = .keycodeAltLeft
    case 58: self = .keycodeAltRight
    case 59: self = .keycodeShiftLeft
    case 60: self = .keycodeShiftRight
    case 61: self = .keycodeTab
    case 62: self = .keycodeSpace
    case 63: self = .keycodeSym
    case 64: self = .keycodeExplorer
    case 65: self = .keycodeEnvelope
    case 66: self = .keycodeEnter
    case 67: self = .keycodeDel
    case 68: self = .keycodeGrave
    case 69: self = .keycodeMinus
    case 70: self = .keycodeEquals
    case 71: self = .keycodeLeftBracket
    case 72: self = .keycodeRightBracket
    case 73: self = .keycodeBackslash
    case 74: self = .keycodeSemicolon
    case 75: self = .keycodeApostrophe
    case 76: self = .keycodeSlash
    case 77: self = .keycodeAt
    case 78: self = .keycodeNum
    case 79: self = .keycodeHeadsethook
    case 80: self = .keycodeFocus
    case 81: self = .keycodePlus
    case 82: self = .keycodeMenu
    case 83: self = .keycodeNotification
    case 84: self = .keycodeSearch
    case 85: self = .keycodeMediaPlayPause
    case 86: self = .keycodeMediaStop
    case 87: self = .keycodeMediaNext
    case 88: self = .keycodeMediaPrevious
    case 89: self = .keycodeMediaRewind
    case 90: self = .keycodeMediaFastForward
    case 91: self = .keycodeMute
    case 92: self = .keycodePageUp
    case 93: self = .keycodePageDown
    case 94: self = .keycodePictsymbols
    case 95: self = .keycodeSwitchCharset
    case 96: self = .keycodeButtonA
    case 97: self = .keycodeButtonB
    case 98: self = .keycodeButtonC
    case 99: self = .keycodeButtonX
    case 100: self = .keycodeButtonY
    case 101: self = .keycodeButtonZ
    case 102: self = .keycodeButtonL1
    case 103: self = .keycodeButtonR1
    case 104: self = .keycodeButtonL2
    case 105: self = .keycodeButtonR2
    case 106: self = .keycodeButtonThumbl
    case 107: self = .keycodeButtonThumbr
    case 108: self = .keycodeButtonStart
    case 109: self = .keycodeButtonSelect
    case 110: self = .keycodeButtonMode
    case 111: self = .keycodeEscape
    case 112: self = .keycodeForwardDel
    case 113: self = .keycodeCtrlLeft
    case 114: self = .keycodeCtrlRight
    case 115: self = .keycodeCapsLock
    case 116: self = .keycodeScrollLock
    case 117: self = .keycodeMetaLeft
    case 118: self = .keycodeMetaRight
    case 119: self = .keycodeFunction
    case 120: self = .keycodeSysrq
    case 121: self = .keycodeBreak
    case 122: self = .keycodeMoveHome
    case 123: self = .keycodeMoveEnd
    case 124: self = .keycodeInsert
    case 125: self = .keycodeForward
    case 126: self = .keycodeMediaPlay
    case 127: self = .keycodeMediaPause
    case 128: self = .keycodeMediaClose
    case 129: self = .keycodeMediaEject
    case 130: self = .keycodeMediaRecord
    case 131: self = .keycodeF1
    case 132: self = .keycodeF2
    case 133: self = .keycodeF3
    case 134: self = .keycodeF4
    case 135: self = .keycodeF5
    case 136: self = .keycodeF6
    case 137: self = .keycodeF7
    case 138: self = .keycodeF8
    case 139: self = .keycodeF9
    case 140: self = .keycodeF10
    case 141: self = .keycodeF11
    case 142: self = .keycodeF12
    case 143: self = .keycodeNumLock
    case 144: self = .keycodeNumpad0
    case 145: self = .keycodeNumpad1
    case 146: self = .keycodeNumpad2
    case 147: self = .keycodeNumpad3
    case 148: self = .keycodeNumpad4
    case 149: self = .keycodeNumpad5
    case 150: self = .keycodeNumpad6
    case 151: self = .keycodeNumpad7
    case 152: self = .keycodeNumpad8
    case 153: self = .keycodeNumpad9
    case 154: self = .keycodeNumpadDivide
    case 155: self = .keycodeNumpadMultiply
    case 156: self = .keycodeNumpadSubtract
    case 157: self = .keycodeNumpadAdd
    case 158: self = .keycodeNumpadDot
    case 159: self = .keycodeNumpadComma
    case 160: self = .keycodeNumpadEnter
    case 161: self = .keycodeNumpadEquals
    case 162: self = .keycodeNumpadLeftParen
    case 163: self = .keycodeNumpadRightParen
    case 164: self = .keycodeVolumeMute
    case 165: self = .keycodeInfo
    case 166: self = .keycodeChannelUp
    case 167: self = .keycodeChannelDown
    case 168: self = .keycodeZoomIn
    case 169: self = .keycodeZoomOut
    case 170: self = .keycodeTv
    case 171: self = .keycodeWindow
    case 172: self = .keycodeGuide
    case 173: self = .keycodeDvr
    case 174: self = .keycodeBookmark
    case 175: self = .keycodeCaptions
    case 176: self = .keycodeSettings
    case 177: self = .keycodeTvPower
    case 178: self = .keycodeTvInput
    case 179: self = .keycodeStbPower
    case 180: self = .keycodeStbInput
    case 181: self = .keycodeAvrPower
    case 182: self = .keycodeAvrInput
    case 183: self = .keycodeProgRed
    case 184: self = .keycodeProgGreen
    case 185: self = .keycodeProgYellow
    case 186: self = .keycodeProgBlue
    case 187: self = .keycodeAppSwitch
    case 188: self = .keycodeButton1
    case 189: self = .keycodeButton2
    case 190: self = .keycodeButton3
    case 191: self = .keycodeButton4
    case 192: self = .keycodeButton5
    case 193: self = .keycodeButton6
    case 194: self = .keycodeButton7
    case 195: self = .keycodeButton8
    case 196: self = .keycodeButton9
    case 197: self = .keycodeButton10
    case 198: self = .keycodeButton11
    case 199: self = .keycodeButton12
    case 200: self = .keycodeButton13
    case 201: self = .keycodeButton14
    case 202: self = .keycodeButton15
    case 203: self = .keycodeButton16
    case 204: self = .keycodeLanguageSwitch
    case 205: self = .keycodeMannerMode
    case 206: self = .keycode3DMode
    case 207: self = .keycodeContacts
    case 208: self = .keycodeCalendar
    case 209: self = .keycodeMusic
    case 210: self = .keycodeCalculator
    case 211: self = .keycodeZenkakuHankaku
    case 212: self = .keycodeEisu
    case 213: self = .keycodeMuhenkan
    case 214: self = .keycodeHenkan
    case 215: self = .keycodeKatakanaHiragana
    case 216: self = .keycodeYen
    case 217: self = .keycodeRo
    case 218: self = .keycodeKana
    case 219: self = .keycodeAssist
    case 220: self = .keycodeBrightnessDown
    case 221: self = .keycodeBrightnessUp
    case 222: self = .keycodeMediaAudioTrack
    case 223: self = .keycodeSleep
    case 224: self = .keycodeWakeup
    case 225: self = .keycodePairing
    case 226: self = .keycodeMediaTopMenu
    case 227: self = .keycode11
    case 228: self = .keycode12
    case 229: self = .keycodeLastChannel
    case 230: self = .keycodeTvDataService
    case 231: self = .keycodeVoiceAssist
    case 232: self = .keycodeTvRadioService
    case 233: self = .keycodeTvTeletext
    case 234: self = .keycodeTvNumberEntry
    case 235: self = .keycodeTvTerrestrialAnalog
    case 236: self = .keycodeTvTerrestrialDigital
    case 237: self = .keycodeTvSatellite
    case 238: self = .keycodeTvSatelliteBs
    case 239: self = .keycodeTvSatelliteCs
    case 240: self = .keycodeTvSatelliteService
    case 241: self = .keycodeTvNetwork
    case 242: self = .keycodeTvAntennaCable
    case 243: self = .keycodeTvInputHdmi1
    case 244: self = .keycodeTvInputHdmi2
    case 245: self = .keycodeTvInputHdmi3
    case 246: self = .keycodeTvInputHdmi4
    case 247: self = .keycodeTvInputComposite1
    case 248: self = .keycodeTvInputComposite2
    case 249: self = .keycodeTvInputComponent1
    case 250: self = .keycodeTvInputComponent2
    case 251: self = .keycodeTvInputVga1
    case 252: self = .keycodeTvAudioDescription
    case 253: self = .keycodeTvAudioDescriptionMixUp
    case 254: self = .keycodeTvAudioDescriptionMixDown
    case 255: self = .keycodeTvZoomMode
    case 256: self = .keycodeTvContentsMenu
    case 257: self = .keycodeTvMediaContextMenu
    case 258: self = .keycodeTvTimerProgramming
    case 259: self = .keycodeHelp
    case 260: self = .keycodeNavigatePrevious
    case 261: self = .keycodeNavigateNext
    case 262: self = .keycodeNavigateIn
    case 263: self = .keycodeNavigateOut
    case 264: self = .keycodeStemPrimary
    case 265: self = .keycodeStem1
    case 266: self = .keycodeStem2
    case 267: self = .keycodeStem3
    case 268: self = .keycodeDpadUpLeft
    case 269: self = .keycodeDpadDownLeft
    case 270: self = .keycodeDpadUpRight
    case 271: self = .keycodeDpadDownRight
    case 272: self = .keycodeMediaSkipForward
    case 273: self = .keycodeMediaSkipBackward
    case 274: self = .keycodeMediaStepForward
    case 275: self = .keycodeMediaStepBackward
    case 276: self = .keycodeSoftSleep
    case 277: self = .keycodeCut
    case 278: self = .keycodeCopy
    case 279: self = .keycodePaste
    case 280: self = .keycodeSystemNavigationUp
    case 281: self = .keycodeSystemNavigationDown
    case 282: self = .keycodeSystemNavigationLeft
    case 283: self = .keycodeSystemNavigationRight
    case 284: self = .keycodeAllApps
    case 285: self = .keycodeRefresh
    case 286: self = .keycodeThumbsUp
    case 287: self = .keycodeThumbsDown
    case 288: self = .keycodeProfileSwitch
    case 289: self = .keycodeVideoApp1
    case 290: self = .keycodeVideoApp2
    case 291: self = .keycodeVideoApp3
    case 292: self = .keycodeVideoApp4
    case 293: self = .keycodeVideoApp5
    case 294: self = .keycodeVideoApp6
    case 295: self = .keycodeVideoApp7
    case 296: self = .keycodeVideoApp8
    case 297: self = .keycodeFeaturedApp1
    case 298: self = .keycodeFeaturedApp2
    case 299: self = .keycodeFeaturedApp3
    case 300: self = .keycodeFeaturedApp4
    case 301: self = .keycodeDemoApp1
    case 302: self = .keycodeDemoApp2
    case 303: self = .keycodeDemoApp3
    case 304: self = .keycodeDemoApp4
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .keycodeUnknown: return 0
    case .keycodeSoftLeft: return 1
    case .keycodeSoftRight: return 2
    case .keycodeHome: return 3
    case .keycodeBack: return 4
    case .keycodeCall: return 5
    case .keycodeEndcall: return 6
    case .keycode0: return 7
    case .keycode1: return 8
    case .keycode2: return 9
    case .keycode3: return 10
    case .keycode4: return 11
    case .keycode5: return 12
    case .keycode6: return 13
    case .keycode7: return 14
    case .keycode8: return 15
    case .keycode9: return 16
    case .keycodeStar: return 17
    case .keycodePound: return 18
    case .keycodeDpadUp: return 19
    case .keycodeDpadDown: return 20
    case .keycodeDpadLeft: return 21
    case .keycodeDpadRight: return 22
    case .keycodeDpadCenter: return 23
    case .keycodeVolumeUp: return 24
    case .keycodeVolumeDown: return 25
    case .keycodePower: return 26
    case .keycodeCamera: return 27
    case .keycodeClear: return 28
    case .keycodeA: return 29
    case .keycodeB: return 30
    case .keycodeC: return 31
    case .keycodeD: return 32
    case .keycodeE: return 33
    case .keycodeF: return 34
    case .keycodeG: return 35
    case .keycodeH: return 36
    case .keycodeI: return 37
    case .keycodeJ: return 38
    case .keycodeK: return 39
    case .keycodeL: return 40
    case .keycodeM: return 41
    case .keycodeN: return 42
    case .keycodeO: return 43
    case .keycodeP: return 44
    case .keycodeQ: return 45
    case .keycodeR: return 46
    case .keycodeS: return 47
    case .keycodeT: return 48
    case .keycodeU: return 49
    case .keycodeV: return 50
    case .keycodeW: return 51
    case .keycodeX: return 52
    case .keycodeY: return 53
    case .keycodeZ: return 54
    case .keycodeComma: return 55
    case .keycodePeriod: return 56
    case .keycodeAltLeft: return 57
    case .keycodeAltRight: return 58
    case .keycodeShiftLeft: return 59
    case .keycodeShiftRight: return 60
    case .keycodeTab: return 61
    case .keycodeSpace: return 62
    case .keycodeSym: return 63
    case .keycodeExplorer: return 64
    case .keycodeEnvelope: return 65
    case .keycodeEnter: return 66
    case .keycodeDel: return 67
    case .keycodeGrave: return 68
    case .keycodeMinus: return 69
    case .keycodeEquals: return 70
    case .keycodeLeftBracket: return 71
    case .keycodeRightBracket: return 72
    case .keycodeBackslash: return 73
    case .keycodeSemicolon: return 74
    case .keycodeApostrophe: return 75
    case .keycodeSlash: return 76
    case .keycodeAt: return 77
    case .keycodeNum: return 78
    case .keycodeHeadsethook: return 79
    case .keycodeFocus: return 80
    case .keycodePlus: return 81
    case .keycodeMenu: return 82
    case .keycodeNotification: return 83
    case .keycodeSearch: return 84
    case .keycodeMediaPlayPause: return 85
    case .keycodeMediaStop: return 86
    case .keycodeMediaNext: return 87
    case .keycodeMediaPrevious: return 88
    case .keycodeMediaRewind: return 89
    case .keycodeMediaFastForward: return 90
    case .keycodeMute: return 91
    case .keycodePageUp: return 92
    case .keycodePageDown: return 93
    case .keycodePictsymbols: return 94
    case .keycodeSwitchCharset: return 95
    case .keycodeButtonA: return 96
    case .keycodeButtonB: return 97
    case .keycodeButtonC: return 98
    case .keycodeButtonX: return 99
    case .keycodeButtonY: return 100
    case .keycodeButtonZ: return 101
    case .keycodeButtonL1: return 102
    case .keycodeButtonR1: return 103
    case .keycodeButtonL2: return 104
    case .keycodeButtonR2: return 105
    case .keycodeButtonThumbl: return 106
    case .keycodeButtonThumbr: return 107
    case .keycodeButtonStart: return 108
    case .keycodeButtonSelect: return 109
    case .keycodeButtonMode: return 110
    case .keycodeEscape: return 111
    case .keycodeForwardDel: return 112
    case .keycodeCtrlLeft: return 113
    case .keycodeCtrlRight: return 114
    case .keycodeCapsLock: return 115
    case .keycodeScrollLock: return 116
    case .keycodeMetaLeft: return 117
    case .keycodeMetaRight: return 118
    case .keycodeFunction: return 119
    case .keycodeSysrq: return 120
    case .keycodeBreak: return 121
    case .keycodeMoveHome: return 122
    case .keycodeMoveEnd: return 123
    case .keycodeInsert: return 124
    case .keycodeForward: return 125
    case .keycodeMediaPlay: return 126
    case .keycodeMediaPause: return 127
    case .keycodeMediaClose: return 128
    case .keycodeMediaEject: return 129
    case .keycodeMediaRecord: return 130
    case .keycodeF1: return 131
    case .keycodeF2: return 132
    case .keycodeF3: return 133
    case .keycodeF4: return 134
    case .keycodeF5: return 135
    case .keycodeF6: return 136
    case .keycodeF7: return 137
    case .keycodeF8: return 138
    case .keycodeF9: return 139
    case .keycodeF10: return 140
    case .keycodeF11: return 141
    case .keycodeF12: return 142
    case .keycodeNumLock: return 143
    case .keycodeNumpad0: return 144
    case .keycodeNumpad1: return 145
    case .keycodeNumpad2: return 146
    case .keycodeNumpad3: return 147
    case .keycodeNumpad4: return 148
    case .keycodeNumpad5: return 149
    case .keycodeNumpad6: return 150
    case .keycodeNumpad7: return 151
    case .keycodeNumpad8: return 152
    case .keycodeNumpad9: return 153
    case .keycodeNumpadDivide: return 154
    case .keycodeNumpadMultiply: return 155
    case .keycodeNumpadSubtract: return 156
    case .keycodeNumpadAdd: return 157
    case .keycodeNumpadDot: return 158
    case .keycodeNumpadComma: return 159
    case .keycodeNumpadEnter: return 160
    case .keycodeNumpadEquals: return 161
    case .keycodeNumpadLeftParen: return 162
    case .keycodeNumpadRightParen: return 163
    case .keycodeVolumeMute: return 164
    case .keycodeInfo: return 165
    case .keycodeChannelUp: return 166
    case .keycodeChannelDown: return 167
    case .keycodeZoomIn: return 168
    case .keycodeZoomOut: return 169
    case .keycodeTv: return 170
    case .keycodeWindow: return 171
    case .keycodeGuide: return 172
    case .keycodeDvr: return 173
    case .keycodeBookmark: return 174
    case .keycodeCaptions: return 175
    case .keycodeSettings: return 176
    case .keycodeTvPower: return 177
    case .keycodeTvInput: return 178
    case .keycodeStbPower: return 179
    case .keycodeStbInput: return 180
    case .keycodeAvrPower: return 181
    case .keycodeAvrInput: return 182
    case .keycodeProgRed: return 183
    case .keycodeProgGreen: return 184
    case .keycodeProgYellow: return 185
    case .keycodeProgBlue: return 186
    case .keycodeAppSwitch: return 187
    case .keycodeButton1: return 188
    case .keycodeButton2: return 189
    case .keycodeButton3: return 190
    case .keycodeButton4: return 191
    case .keycodeButton5: return 192
    case .keycodeButton6: return 193
    case .keycodeButton7: return 194
    case .keycodeButton8: return 195
    case .keycodeButton9: return 196
    case .keycodeButton10: return 197
    case .keycodeButton11: return 198
    case .keycodeButton12: return 199
    case .keycodeButton13: return 200
    case .keycodeButton14: return 201
    case .keycodeButton15: return 202
    case .keycodeButton16: return 203
    case .keycodeLanguageSwitch: return 204
    case .keycodeMannerMode: return 205
    case .keycode3DMode: return 206
    case .keycodeContacts: return 207
    case .keycodeCalendar: return 208
    case .keycodeMusic: return 209
    case .keycodeCalculator: return 210
    case .keycodeZenkakuHankaku: return 211
    case .keycodeEisu: return 212
    case .keycodeMuhenkan: return 213
    case .keycodeHenkan: return 214
    case .keycodeKatakanaHiragana: return 215
    case .keycodeYen: return 216
    case .keycodeRo: return 217
    case .keycodeKana: return 218
    case .keycodeAssist: return 219
    case .keycodeBrightnessDown: return 220
    case .keycodeBrightnessUp: return 221
    case .keycodeMediaAudioTrack: return 222
    case .keycodeSleep: return 223
    case .keycodeWakeup: return 224
    case .keycodePairing: return 225
    case .keycodeMediaTopMenu: return 226
    case .keycode11: return 227
    case .keycode12: return 228
    case .keycodeLastChannel: return 229
    case .keycodeTvDataService: return 230
    case .keycodeVoiceAssist: return 231
    case .keycodeTvRadioService: return 232
    case .keycodeTvTeletext: return 233
    case .keycodeTvNumberEntry: return 234
    case .keycodeTvTerrestrialAnalog: return 235
    case .keycodeTvTerrestrialDigital: return 236
    case .keycodeTvSatellite: return 237
    case .keycodeTvSatelliteBs: return 238
    case .keycodeTvSatelliteCs: return 239
    case .keycodeTvSatelliteService: return 240
    case .keycodeTvNetwork: return 241
    case .keycodeTvAntennaCable: return 242
    case .keycodeTvInputHdmi1: return 243
    case .keycodeTvInputHdmi2: return 244
    case .keycodeTvInputHdmi3: return 245
    case .keycodeTvInputHdmi4: return 246
    case .keycodeTvInputComposite1: return 247
    case .keycodeTvInputComposite2: return 248
    case .keycodeTvInputComponent1: return 249
    case .keycodeTvInputComponent2: return 250
    case .keycodeTvInputVga1: return 251
    case .keycodeTvAudioDescription: return 252
    case .keycodeTvAudioDescriptionMixUp: return 253
    case .keycodeTvAudioDescriptionMixDown: return 254
    case .keycodeTvZoomMode: return 255
    case .keycodeTvContentsMenu: return 256
    case .keycodeTvMediaContextMenu: return 257
    case .keycodeTvTimerProgramming: return 258
    case .keycodeHelp: return 259
    case .keycodeNavigatePrevious: return 260
    case .keycodeNavigateNext: return 261
    case .keycodeNavigateIn: return 262
    case .keycodeNavigateOut: return 263
    case .keycodeStemPrimary: return 264
    case .keycodeStem1: return 265
    case .keycodeStem2: return 266
    case .keycodeStem3: return 267
    case .keycodeDpadUpLeft: return 268
    case .keycodeDpadDownLeft: return 269
    case .keycodeDpadUpRight: return 270
    case .keycodeDpadDownRight: return 271
    case .keycodeMediaSkipForward: return 272
    case .keycodeMediaSkipBackward: return 273
    case .keycodeMediaStepForward: return 274
    case .keycodeMediaStepBackward: return 275
    case .keycodeSoftSleep: return 276
    case .keycodeCut: return 277
    case .keycodeCopy: return 278
    case .keycodePaste: return 279
    case .keycodeSystemNavigationUp: return 280
    case .keycodeSystemNavigationDown: return 281
    case .keycodeSystemNavigationLeft: return 282
    case .keycodeSystemNavigationRight: return 283
    case .keycodeAllApps: return 284
    case .keycodeRefresh: return 285
    case .keycodeThumbsUp: return 286
    case .keycodeThumbsDown: return 287
    case .keycodeProfileSwitch: return 288
    case .keycodeVideoApp1: return 289
    case .keycodeVideoApp2: return 290
    case .keycodeVideoApp3: return 291
    case .keycodeVideoApp4: return 292
    case .keycodeVideoApp5: return 293
    case .keycodeVideoApp6: return 294
    case .keycodeVideoApp7: return 295
    case .keycodeVideoApp8: return 296
    case .keycodeFeaturedApp1: return 297
    case .keycodeFeaturedApp2: return 298
    case .keycodeFeaturedApp3: return 299
    case .keycodeFeaturedApp4: return 300
    case .keycodeDemoApp1: return 301
    case .keycodeDemoApp2: return 302
    case .keycodeDemoApp3: return 303
    case .keycodeDemoApp4: return 304
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Remote_RemoteKeyCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Remote_RemoteKeyCode] = [
    .keycodeUnknown,
    .keycodeSoftLeft,
    .keycodeSoftRight,
    .keycodeHome,
    .keycodeBack,
    .keycodeCall,
    .keycodeEndcall,
    .keycode0,
    .keycode1,
    .keycode2,
    .keycode3,
    .keycode4,
    .keycode5,
    .keycode6,
    .keycode7,
    .keycode8,
    .keycode9,
    .keycodeStar,
    .keycodePound,
    .keycodeDpadUp,
    .keycodeDpadDown,
    .keycodeDpadLeft,
    .keycodeDpadRight,
    .keycodeDpadCenter,
    .keycodeVolumeUp,
    .keycodeVolumeDown,
    .keycodePower,
    .keycodeCamera,
    .keycodeClear,
    .keycodeA,
    .keycodeB,
    .keycodeC,
    .keycodeD,
    .keycodeE,
    .keycodeF,
    .keycodeG,
    .keycodeH,
    .keycodeI,
    .keycodeJ,
    .keycodeK,
    .keycodeL,
    .keycodeM,
    .keycodeN,
    .keycodeO,
    .keycodeP,
    .keycodeQ,
    .keycodeR,
    .keycodeS,
    .keycodeT,
    .keycodeU,
    .keycodeV,
    .keycodeW,
    .keycodeX,
    .keycodeY,
    .keycodeZ,
    .keycodeComma,
    .keycodePeriod,
    .keycodeAltLeft,
    .keycodeAltRight,
    .keycodeShiftLeft,
    .keycodeShiftRight,
    .keycodeTab,
    .keycodeSpace,
    .keycodeSym,
    .keycodeExplorer,
    .keycodeEnvelope,
    .keycodeEnter,
    .keycodeDel,
    .keycodeGrave,
    .keycodeMinus,
    .keycodeEquals,
    .keycodeLeftBracket,
    .keycodeRightBracket,
    .keycodeBackslash,
    .keycodeSemicolon,
    .keycodeApostrophe,
    .keycodeSlash,
    .keycodeAt,
    .keycodeNum,
    .keycodeHeadsethook,
    .keycodeFocus,
    .keycodePlus,
    .keycodeMenu,
    .keycodeNotification,
    .keycodeSearch,
    .keycodeMediaPlayPause,
    .keycodeMediaStop,
    .keycodeMediaNext,
    .keycodeMediaPrevious,
    .keycodeMediaRewind,
    .keycodeMediaFastForward,
    .keycodeMute,
    .keycodePageUp,
    .keycodePageDown,
    .keycodePictsymbols,
    .keycodeSwitchCharset,
    .keycodeButtonA,
    .keycodeButtonB,
    .keycodeButtonC,
    .keycodeButtonX,
    .keycodeButtonY,
    .keycodeButtonZ,
    .keycodeButtonL1,
    .keycodeButtonR1,
    .keycodeButtonL2,
    .keycodeButtonR2,
    .keycodeButtonThumbl,
    .keycodeButtonThumbr,
    .keycodeButtonStart,
    .keycodeButtonSelect,
    .keycodeButtonMode,
    .keycodeEscape,
    .keycodeForwardDel,
    .keycodeCtrlLeft,
    .keycodeCtrlRight,
    .keycodeCapsLock,
    .keycodeScrollLock,
    .keycodeMetaLeft,
    .keycodeMetaRight,
    .keycodeFunction,
    .keycodeSysrq,
    .keycodeBreak,
    .keycodeMoveHome,
    .keycodeMoveEnd,
    .keycodeInsert,
    .keycodeForward,
    .keycodeMediaPlay,
    .keycodeMediaPause,
    .keycodeMediaClose,
    .keycodeMediaEject,
    .keycodeMediaRecord,
    .keycodeF1,
    .keycodeF2,
    .keycodeF3,
    .keycodeF4,
    .keycodeF5,
    .keycodeF6,
    .keycodeF7,
    .keycodeF8,
    .keycodeF9,
    .keycodeF10,
    .keycodeF11,
    .keycodeF12,
    .keycodeNumLock,
    .keycodeNumpad0,
    .keycodeNumpad1,
    .keycodeNumpad2,
    .keycodeNumpad3,
    .keycodeNumpad4,
    .keycodeNumpad5,
    .keycodeNumpad6,
    .keycodeNumpad7,
    .keycodeNumpad8,
    .keycodeNumpad9,
    .keycodeNumpadDivide,
    .keycodeNumpadMultiply,
    .keycodeNumpadSubtract,
    .keycodeNumpadAdd,
    .keycodeNumpadDot,
    .keycodeNumpadComma,
    .keycodeNumpadEnter,
    .keycodeNumpadEquals,
    .keycodeNumpadLeftParen,
    .keycodeNumpadRightParen,
    .keycodeVolumeMute,
    .keycodeInfo,
    .keycodeChannelUp,
    .keycodeChannelDown,
    .keycodeZoomIn,
    .keycodeZoomOut,
    .keycodeTv,
    .keycodeWindow,
    .keycodeGuide,
    .keycodeDvr,
    .keycodeBookmark,
    .keycodeCaptions,
    .keycodeSettings,
    .keycodeTvPower,
    .keycodeTvInput,
    .keycodeStbPower,
    .keycodeStbInput,
    .keycodeAvrPower,
    .keycodeAvrInput,
    .keycodeProgRed,
    .keycodeProgGreen,
    .keycodeProgYellow,
    .keycodeProgBlue,
    .keycodeAppSwitch,
    .keycodeButton1,
    .keycodeButton2,
    .keycodeButton3,
    .keycodeButton4,
    .keycodeButton5,
    .keycodeButton6,
    .keycodeButton7,
    .keycodeButton8,
    .keycodeButton9,
    .keycodeButton10,
    .keycodeButton11,
    .keycodeButton12,
    .keycodeButton13,
    .keycodeButton14,
    .keycodeButton15,
    .keycodeButton16,
    .keycodeLanguageSwitch,
    .keycodeMannerMode,
    .keycode3DMode,
    .keycodeContacts,
    .keycodeCalendar,
    .keycodeMusic,
    .keycodeCalculator,
    .keycodeZenkakuHankaku,
    .keycodeEisu,
    .keycodeMuhenkan,
    .keycodeHenkan,
    .keycodeKatakanaHiragana,
    .keycodeYen,
    .keycodeRo,
    .keycodeKana,
    .keycodeAssist,
    .keycodeBrightnessDown,
    .keycodeBrightnessUp,
    .keycodeMediaAudioTrack,
    .keycodeSleep,
    .keycodeWakeup,
    .keycodePairing,
    .keycodeMediaTopMenu,
    .keycode11,
    .keycode12,
    .keycodeLastChannel,
    .keycodeTvDataService,
    .keycodeVoiceAssist,
    .keycodeTvRadioService,
    .keycodeTvTeletext,
    .keycodeTvNumberEntry,
    .keycodeTvTerrestrialAnalog,
    .keycodeTvTerrestrialDigital,
    .keycodeTvSatellite,
    .keycodeTvSatelliteBs,
    .keycodeTvSatelliteCs,
    .keycodeTvSatelliteService,
    .keycodeTvNetwork,
    .keycodeTvAntennaCable,
    .keycodeTvInputHdmi1,
    .keycodeTvInputHdmi2,
    .keycodeTvInputHdmi3,
    .keycodeTvInputHdmi4,
    .keycodeTvInputComposite1,
    .keycodeTvInputComposite2,
    .keycodeTvInputComponent1,
    .keycodeTvInputComponent2,
    .keycodeTvInputVga1,
    .keycodeTvAudioDescription,
    .keycodeTvAudioDescriptionMixUp,
    .keycodeTvAudioDescriptionMixDown,
    .keycodeTvZoomMode,
    .keycodeTvContentsMenu,
    .keycodeTvMediaContextMenu,
    .keycodeTvTimerProgramming,
    .keycodeHelp,
    .keycodeNavigatePrevious,
    .keycodeNavigateNext,
    .keycodeNavigateIn,
    .keycodeNavigateOut,
    .keycodeStemPrimary,
    .keycodeStem1,
    .keycodeStem2,
    .keycodeStem3,
    .keycodeDpadUpLeft,
    .keycodeDpadDownLeft,
    .keycodeDpadUpRight,
    .keycodeDpadDownRight,
    .keycodeMediaSkipForward,
    .keycodeMediaSkipBackward,
    .keycodeMediaStepForward,
    .keycodeMediaStepBackward,
    .keycodeSoftSleep,
    .keycodeCut,
    .keycodeCopy,
    .keycodePaste,
    .keycodeSystemNavigationUp,
    .keycodeSystemNavigationDown,
    .keycodeSystemNavigationLeft,
    .keycodeSystemNavigationRight,
    .keycodeAllApps,
    .keycodeRefresh,
    .keycodeThumbsUp,
    .keycodeThumbsDown,
    .keycodeProfileSwitch,
    .keycodeVideoApp1,
    .keycodeVideoApp2,
    .keycodeVideoApp3,
    .keycodeVideoApp4,
    .keycodeVideoApp5,
    .keycodeVideoApp6,
    .keycodeVideoApp7,
    .keycodeVideoApp8,
    .keycodeFeaturedApp1,
    .keycodeFeaturedApp2,
    .keycodeFeaturedApp3,
    .keycodeFeaturedApp4,
    .keycodeDemoApp1,
    .keycodeDemoApp2,
    .keycodeDemoApp3,
    .keycodeDemoApp4,
  ]
}

#endif  // swift(>=4.2)

enum Remote_RemoteDirection: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownDirection // = 0
  case startLong // = 1
  case endLong // = 2
  case short // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownDirection
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDirection
    case 1: self = .startLong
    case 2: self = .endLong
    case 3: self = .short
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDirection: return 0
    case .startLong: return 1
    case .endLong: return 2
    case .short: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Remote_RemoteDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Remote_RemoteDirection] = [
    .unknownDirection,
    .startLong,
    .endLong,
    .short,
  ]
}

#endif  // swift(>=4.2)

struct Remote_RemoteAppLinkLaunchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appLink: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteResetPreferredAudioDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteSetPreferredAudioDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteAdjustVolumeLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteSetVolumeLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknown1: UInt32 = 0

  var unknown2: UInt32 = 0

  var playerModel: String = String()

  var unknown4: UInt32 = 0

  var unknown5: UInt32 = 0

  var volumeMax: UInt32 = 0

  var volumeLevel: UInt32 = 0

  var volumeMuted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var started: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteVoiceEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteVoicePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteVoiceBegin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteTextFieldStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var counterField: Int32 = 0

  var value: String = String()

  var start: Int32 = 0

  var end: Int32 = 0

  var int5: Int32 = 0

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteImeShowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var remoteTextFieldStatus: Remote_RemoteTextFieldStatus {
    get {return _remoteTextFieldStatus ?? Remote_RemoteTextFieldStatus()}
    set {_remoteTextFieldStatus = newValue}
  }
  /// Returns true if `remoteTextFieldStatus` has been explicitly set.
  var hasRemoteTextFieldStatus: Bool {return self._remoteTextFieldStatus != nil}
  /// Clears the value of `remoteTextFieldStatus`. Subsequent reads from it will return its default value.
  mutating func clearRemoteTextFieldStatus() {self._remoteTextFieldStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _remoteTextFieldStatus: Remote_RemoteTextFieldStatus? = nil
}

struct Remote_RemoteEditInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var insert: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteImeBatchEdit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imeCounter: Int32 = 0

  var fieldCounter: Int32 = 0

  var editInfo: Remote_RemoteEditInfo {
    get {return _editInfo ?? Remote_RemoteEditInfo()}
    set {_editInfo = newValue}
  }
  /// Returns true if `editInfo` has been explicitly set.
  var hasEditInfo: Bool {return self._editInfo != nil}
  /// Clears the value of `editInfo`. Subsequent reads from it will return its default value.
  mutating func clearEditInfo() {self._editInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _editInfo: Remote_RemoteEditInfo? = nil
}

struct Remote_RemoteAppInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var counter: Int32 = 0

  var int2: Int32 = 0

  var int3: Int32 = 0

  var int4: String = String()

  var int7: Int32 = 0

  var int8: Int32 = 0

  var label: String = String()

  var appPackage: String = String()

  var int13: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteImeKeyInject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appInfo: Remote_RemoteAppInfo {
    get {return _appInfo ?? Remote_RemoteAppInfo()}
    set {_appInfo = newValue}
  }
  /// Returns true if `appInfo` has been explicitly set.
  var hasAppInfo: Bool {return self._appInfo != nil}
  /// Clears the value of `appInfo`. Subsequent reads from it will return its default value.
  mutating func clearAppInfo() {self._appInfo = nil}

  var textFieldStatus: Remote_RemoteTextFieldStatus {
    get {return _textFieldStatus ?? Remote_RemoteTextFieldStatus()}
    set {_textFieldStatus = newValue}
  }
  /// Returns true if `textFieldStatus` has been explicitly set.
  var hasTextFieldStatus: Bool {return self._textFieldStatus != nil}
  /// Clears the value of `textFieldStatus`. Subsequent reads from it will return its default value.
  mutating func clearTextFieldStatus() {self._textFieldStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appInfo: Remote_RemoteAppInfo? = nil
  fileprivate var _textFieldStatus: Remote_RemoteTextFieldStatus? = nil
}

struct Remote_RemoteKeyInject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyCode: Remote_RemoteKeyCode = .keycodeUnknown

  var direction: Remote_RemoteDirection = .unknownDirection

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemotePingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var val1: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemotePingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var val1: Int32 = 0

  var val2: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteSetActive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var active: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var model: String = String()

  var vendor: String = String()

  var unknown1: Int32 = 0

  var unknown2: String = String()

  var packageName: String = String()

  var appVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Remote_RemoteConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code1: Int32 = 0

  var deviceInfo: Remote_RemoteDeviceInfo {
    get {return _deviceInfo ?? Remote_RemoteDeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  mutating func clearDeviceInfo() {self._deviceInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceInfo: Remote_RemoteDeviceInfo? = nil
}

struct Remote_RemoteError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var message: Remote_RemoteMessage {
    get {return _storage._message ?? Remote_RemoteMessage()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Remote_RemoteMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var remoteConfigure: Remote_RemoteConfigure {
    get {return _storage._remoteConfigure ?? Remote_RemoteConfigure()}
    set {_uniqueStorage()._remoteConfigure = newValue}
  }
  /// Returns true if `remoteConfigure` has been explicitly set.
  var hasRemoteConfigure: Bool {return _storage._remoteConfigure != nil}
  /// Clears the value of `remoteConfigure`. Subsequent reads from it will return its default value.
  mutating func clearRemoteConfigure() {_uniqueStorage()._remoteConfigure = nil}

  var remoteSetActive: Remote_RemoteSetActive {
    get {return _storage._remoteSetActive ?? Remote_RemoteSetActive()}
    set {_uniqueStorage()._remoteSetActive = newValue}
  }
  /// Returns true if `remoteSetActive` has been explicitly set.
  var hasRemoteSetActive: Bool {return _storage._remoteSetActive != nil}
  /// Clears the value of `remoteSetActive`. Subsequent reads from it will return its default value.
  mutating func clearRemoteSetActive() {_uniqueStorage()._remoteSetActive = nil}

  var remoteError: Remote_RemoteError {
    get {return _storage._remoteError ?? Remote_RemoteError()}
    set {_uniqueStorage()._remoteError = newValue}
  }
  /// Returns true if `remoteError` has been explicitly set.
  var hasRemoteError: Bool {return _storage._remoteError != nil}
  /// Clears the value of `remoteError`. Subsequent reads from it will return its default value.
  mutating func clearRemoteError() {_uniqueStorage()._remoteError = nil}

  var remotePingRequest: Remote_RemotePingRequest {
    get {return _storage._remotePingRequest ?? Remote_RemotePingRequest()}
    set {_uniqueStorage()._remotePingRequest = newValue}
  }
  /// Returns true if `remotePingRequest` has been explicitly set.
  var hasRemotePingRequest: Bool {return _storage._remotePingRequest != nil}
  /// Clears the value of `remotePingRequest`. Subsequent reads from it will return its default value.
  mutating func clearRemotePingRequest() {_uniqueStorage()._remotePingRequest = nil}

  var remotePingResponse: Remote_RemotePingResponse {
    get {return _storage._remotePingResponse ?? Remote_RemotePingResponse()}
    set {_uniqueStorage()._remotePingResponse = newValue}
  }
  /// Returns true if `remotePingResponse` has been explicitly set.
  var hasRemotePingResponse: Bool {return _storage._remotePingResponse != nil}
  /// Clears the value of `remotePingResponse`. Subsequent reads from it will return its default value.
  mutating func clearRemotePingResponse() {_uniqueStorage()._remotePingResponse = nil}

  var remoteKeyInject: Remote_RemoteKeyInject {
    get {return _storage._remoteKeyInject ?? Remote_RemoteKeyInject()}
    set {_uniqueStorage()._remoteKeyInject = newValue}
  }
  /// Returns true if `remoteKeyInject` has been explicitly set.
  var hasRemoteKeyInject: Bool {return _storage._remoteKeyInject != nil}
  /// Clears the value of `remoteKeyInject`. Subsequent reads from it will return its default value.
  mutating func clearRemoteKeyInject() {_uniqueStorage()._remoteKeyInject = nil}

  var remoteImeKeyInject: Remote_RemoteImeKeyInject {
    get {return _storage._remoteImeKeyInject ?? Remote_RemoteImeKeyInject()}
    set {_uniqueStorage()._remoteImeKeyInject = newValue}
  }
  /// Returns true if `remoteImeKeyInject` has been explicitly set.
  var hasRemoteImeKeyInject: Bool {return _storage._remoteImeKeyInject != nil}
  /// Clears the value of `remoteImeKeyInject`. Subsequent reads from it will return its default value.
  mutating func clearRemoteImeKeyInject() {_uniqueStorage()._remoteImeKeyInject = nil}

  var remoteImeBatchEdit: Remote_RemoteImeBatchEdit {
    get {return _storage._remoteImeBatchEdit ?? Remote_RemoteImeBatchEdit()}
    set {_uniqueStorage()._remoteImeBatchEdit = newValue}
  }
  /// Returns true if `remoteImeBatchEdit` has been explicitly set.
  var hasRemoteImeBatchEdit: Bool {return _storage._remoteImeBatchEdit != nil}
  /// Clears the value of `remoteImeBatchEdit`. Subsequent reads from it will return its default value.
  mutating func clearRemoteImeBatchEdit() {_uniqueStorage()._remoteImeBatchEdit = nil}

  var remoteImeShowRequest: Remote_RemoteImeShowRequest {
    get {return _storage._remoteImeShowRequest ?? Remote_RemoteImeShowRequest()}
    set {_uniqueStorage()._remoteImeShowRequest = newValue}
  }
  /// Returns true if `remoteImeShowRequest` has been explicitly set.
  var hasRemoteImeShowRequest: Bool {return _storage._remoteImeShowRequest != nil}
  /// Clears the value of `remoteImeShowRequest`. Subsequent reads from it will return its default value.
  mutating func clearRemoteImeShowRequest() {_uniqueStorage()._remoteImeShowRequest = nil}

  var remoteVoiceBegin: Remote_RemoteVoiceBegin {
    get {return _storage._remoteVoiceBegin ?? Remote_RemoteVoiceBegin()}
    set {_uniqueStorage()._remoteVoiceBegin = newValue}
  }
  /// Returns true if `remoteVoiceBegin` has been explicitly set.
  var hasRemoteVoiceBegin: Bool {return _storage._remoteVoiceBegin != nil}
  /// Clears the value of `remoteVoiceBegin`. Subsequent reads from it will return its default value.
  mutating func clearRemoteVoiceBegin() {_uniqueStorage()._remoteVoiceBegin = nil}

  var remoteVoicePayload: Remote_RemoteVoicePayload {
    get {return _storage._remoteVoicePayload ?? Remote_RemoteVoicePayload()}
    set {_uniqueStorage()._remoteVoicePayload = newValue}
  }
  /// Returns true if `remoteVoicePayload` has been explicitly set.
  var hasRemoteVoicePayload: Bool {return _storage._remoteVoicePayload != nil}
  /// Clears the value of `remoteVoicePayload`. Subsequent reads from it will return its default value.
  mutating func clearRemoteVoicePayload() {_uniqueStorage()._remoteVoicePayload = nil}

  var remoteVoiceEnd: Remote_RemoteVoiceEnd {
    get {return _storage._remoteVoiceEnd ?? Remote_RemoteVoiceEnd()}
    set {_uniqueStorage()._remoteVoiceEnd = newValue}
  }
  /// Returns true if `remoteVoiceEnd` has been explicitly set.
  var hasRemoteVoiceEnd: Bool {return _storage._remoteVoiceEnd != nil}
  /// Clears the value of `remoteVoiceEnd`. Subsequent reads from it will return its default value.
  mutating func clearRemoteVoiceEnd() {_uniqueStorage()._remoteVoiceEnd = nil}

  var remoteStart: Remote_RemoteStart {
    get {return _storage._remoteStart ?? Remote_RemoteStart()}
    set {_uniqueStorage()._remoteStart = newValue}
  }
  /// Returns true if `remoteStart` has been explicitly set.
  var hasRemoteStart: Bool {return _storage._remoteStart != nil}
  /// Clears the value of `remoteStart`. Subsequent reads from it will return its default value.
  mutating func clearRemoteStart() {_uniqueStorage()._remoteStart = nil}

  var remoteSetVolumeLevel: Remote_RemoteSetVolumeLevel {
    get {return _storage._remoteSetVolumeLevel ?? Remote_RemoteSetVolumeLevel()}
    set {_uniqueStorage()._remoteSetVolumeLevel = newValue}
  }
  /// Returns true if `remoteSetVolumeLevel` has been explicitly set.
  var hasRemoteSetVolumeLevel: Bool {return _storage._remoteSetVolumeLevel != nil}
  /// Clears the value of `remoteSetVolumeLevel`. Subsequent reads from it will return its default value.
  mutating func clearRemoteSetVolumeLevel() {_uniqueStorage()._remoteSetVolumeLevel = nil}

  var remoteAdjustVolumeLevel: Remote_RemoteAdjustVolumeLevel {
    get {return _storage._remoteAdjustVolumeLevel ?? Remote_RemoteAdjustVolumeLevel()}
    set {_uniqueStorage()._remoteAdjustVolumeLevel = newValue}
  }
  /// Returns true if `remoteAdjustVolumeLevel` has been explicitly set.
  var hasRemoteAdjustVolumeLevel: Bool {return _storage._remoteAdjustVolumeLevel != nil}
  /// Clears the value of `remoteAdjustVolumeLevel`. Subsequent reads from it will return its default value.
  mutating func clearRemoteAdjustVolumeLevel() {_uniqueStorage()._remoteAdjustVolumeLevel = nil}

  var remoteSetPreferredAudioDevice: Remote_RemoteSetPreferredAudioDevice {
    get {return _storage._remoteSetPreferredAudioDevice ?? Remote_RemoteSetPreferredAudioDevice()}
    set {_uniqueStorage()._remoteSetPreferredAudioDevice = newValue}
  }
  /// Returns true if `remoteSetPreferredAudioDevice` has been explicitly set.
  var hasRemoteSetPreferredAudioDevice: Bool {return _storage._remoteSetPreferredAudioDevice != nil}
  /// Clears the value of `remoteSetPreferredAudioDevice`. Subsequent reads from it will return its default value.
  mutating func clearRemoteSetPreferredAudioDevice() {_uniqueStorage()._remoteSetPreferredAudioDevice = nil}

  var remoteResetPreferredAudioDevice: Remote_RemoteResetPreferredAudioDevice {
    get {return _storage._remoteResetPreferredAudioDevice ?? Remote_RemoteResetPreferredAudioDevice()}
    set {_uniqueStorage()._remoteResetPreferredAudioDevice = newValue}
  }
  /// Returns true if `remoteResetPreferredAudioDevice` has been explicitly set.
  var hasRemoteResetPreferredAudioDevice: Bool {return _storage._remoteResetPreferredAudioDevice != nil}
  /// Clears the value of `remoteResetPreferredAudioDevice`. Subsequent reads from it will return its default value.
  mutating func clearRemoteResetPreferredAudioDevice() {_uniqueStorage()._remoteResetPreferredAudioDevice = nil}

  var remoteAppLinkLaunchRequest: Remote_RemoteAppLinkLaunchRequest {
    get {return _storage._remoteAppLinkLaunchRequest ?? Remote_RemoteAppLinkLaunchRequest()}
    set {_uniqueStorage()._remoteAppLinkLaunchRequest = newValue}
  }
  /// Returns true if `remoteAppLinkLaunchRequest` has been explicitly set.
  var hasRemoteAppLinkLaunchRequest: Bool {return _storage._remoteAppLinkLaunchRequest != nil}
  /// Clears the value of `remoteAppLinkLaunchRequest`. Subsequent reads from it will return its default value.
  mutating func clearRemoteAppLinkLaunchRequest() {_uniqueStorage()._remoteAppLinkLaunchRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Remote_RemoteKeyCode: @unchecked Sendable {}
extension Remote_RemoteDirection: @unchecked Sendable {}
extension Remote_RemoteAppLinkLaunchRequest: @unchecked Sendable {}
extension Remote_RemoteResetPreferredAudioDevice: @unchecked Sendable {}
extension Remote_RemoteSetPreferredAudioDevice: @unchecked Sendable {}
extension Remote_RemoteAdjustVolumeLevel: @unchecked Sendable {}
extension Remote_RemoteSetVolumeLevel: @unchecked Sendable {}
extension Remote_RemoteStart: @unchecked Sendable {}
extension Remote_RemoteVoiceEnd: @unchecked Sendable {}
extension Remote_RemoteVoicePayload: @unchecked Sendable {}
extension Remote_RemoteVoiceBegin: @unchecked Sendable {}
extension Remote_RemoteTextFieldStatus: @unchecked Sendable {}
extension Remote_RemoteImeShowRequest: @unchecked Sendable {}
extension Remote_RemoteEditInfo: @unchecked Sendable {}
extension Remote_RemoteImeBatchEdit: @unchecked Sendable {}
extension Remote_RemoteAppInfo: @unchecked Sendable {}
extension Remote_RemoteImeKeyInject: @unchecked Sendable {}
extension Remote_RemoteKeyInject: @unchecked Sendable {}
extension Remote_RemotePingResponse: @unchecked Sendable {}
extension Remote_RemotePingRequest: @unchecked Sendable {}
extension Remote_RemoteSetActive: @unchecked Sendable {}
extension Remote_RemoteDeviceInfo: @unchecked Sendable {}
extension Remote_RemoteConfigure: @unchecked Sendable {}
extension Remote_RemoteError: @unchecked Sendable {}
extension Remote_RemoteMessage: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "remote"

extension Remote_RemoteKeyCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEYCODE_UNKNOWN"),
    1: .same(proto: "KEYCODE_SOFT_LEFT"),
    2: .same(proto: "KEYCODE_SOFT_RIGHT"),
    3: .same(proto: "KEYCODE_HOME"),
    4: .same(proto: "KEYCODE_BACK"),
    5: .same(proto: "KEYCODE_CALL"),
    6: .same(proto: "KEYCODE_ENDCALL"),
    7: .same(proto: "KEYCODE_0"),
    8: .same(proto: "KEYCODE_1"),
    9: .same(proto: "KEYCODE_2"),
    10: .same(proto: "KEYCODE_3"),
    11: .same(proto: "KEYCODE_4"),
    12: .same(proto: "KEYCODE_5"),
    13: .same(proto: "KEYCODE_6"),
    14: .same(proto: "KEYCODE_7"),
    15: .same(proto: "KEYCODE_8"),
    16: .same(proto: "KEYCODE_9"),
    17: .same(proto: "KEYCODE_STAR"),
    18: .same(proto: "KEYCODE_POUND"),
    19: .same(proto: "KEYCODE_DPAD_UP"),
    20: .same(proto: "KEYCODE_DPAD_DOWN"),
    21: .same(proto: "KEYCODE_DPAD_LEFT"),
    22: .same(proto: "KEYCODE_DPAD_RIGHT"),
    23: .same(proto: "KEYCODE_DPAD_CENTER"),
    24: .same(proto: "KEYCODE_VOLUME_UP"),
    25: .same(proto: "KEYCODE_VOLUME_DOWN"),
    26: .same(proto: "KEYCODE_POWER"),
    27: .same(proto: "KEYCODE_CAMERA"),
    28: .same(proto: "KEYCODE_CLEAR"),
    29: .same(proto: "KEYCODE_A"),
    30: .same(proto: "KEYCODE_B"),
    31: .same(proto: "KEYCODE_C"),
    32: .same(proto: "KEYCODE_D"),
    33: .same(proto: "KEYCODE_E"),
    34: .same(proto: "KEYCODE_F"),
    35: .same(proto: "KEYCODE_G"),
    36: .same(proto: "KEYCODE_H"),
    37: .same(proto: "KEYCODE_I"),
    38: .same(proto: "KEYCODE_J"),
    39: .same(proto: "KEYCODE_K"),
    40: .same(proto: "KEYCODE_L"),
    41: .same(proto: "KEYCODE_M"),
    42: .same(proto: "KEYCODE_N"),
    43: .same(proto: "KEYCODE_O"),
    44: .same(proto: "KEYCODE_P"),
    45: .same(proto: "KEYCODE_Q"),
    46: .same(proto: "KEYCODE_R"),
    47: .same(proto: "KEYCODE_S"),
    48: .same(proto: "KEYCODE_T"),
    49: .same(proto: "KEYCODE_U"),
    50: .same(proto: "KEYCODE_V"),
    51: .same(proto: "KEYCODE_W"),
    52: .same(proto: "KEYCODE_X"),
    53: .same(proto: "KEYCODE_Y"),
    54: .same(proto: "KEYCODE_Z"),
    55: .same(proto: "KEYCODE_COMMA"),
    56: .same(proto: "KEYCODE_PERIOD"),
    57: .same(proto: "KEYCODE_ALT_LEFT"),
    58: .same(proto: "KEYCODE_ALT_RIGHT"),
    59: .same(proto: "KEYCODE_SHIFT_LEFT"),
    60: .same(proto: "KEYCODE_SHIFT_RIGHT"),
    61: .same(proto: "KEYCODE_TAB"),
    62: .same(proto: "KEYCODE_SPACE"),
    63: .same(proto: "KEYCODE_SYM"),
    64: .same(proto: "KEYCODE_EXPLORER"),
    65: .same(proto: "KEYCODE_ENVELOPE"),
    66: .same(proto: "KEYCODE_ENTER"),
    67: .same(proto: "KEYCODE_DEL"),
    68: .same(proto: "KEYCODE_GRAVE"),
    69: .same(proto: "KEYCODE_MINUS"),
    70: .same(proto: "KEYCODE_EQUALS"),
    71: .same(proto: "KEYCODE_LEFT_BRACKET"),
    72: .same(proto: "KEYCODE_RIGHT_BRACKET"),
    73: .same(proto: "KEYCODE_BACKSLASH"),
    74: .same(proto: "KEYCODE_SEMICOLON"),
    75: .same(proto: "KEYCODE_APOSTROPHE"),
    76: .same(proto: "KEYCODE_SLASH"),
    77: .same(proto: "KEYCODE_AT"),
    78: .same(proto: "KEYCODE_NUM"),
    79: .same(proto: "KEYCODE_HEADSETHOOK"),
    80: .same(proto: "KEYCODE_FOCUS"),
    81: .same(proto: "KEYCODE_PLUS"),
    82: .same(proto: "KEYCODE_MENU"),
    83: .same(proto: "KEYCODE_NOTIFICATION"),
    84: .same(proto: "KEYCODE_SEARCH"),
    85: .same(proto: "KEYCODE_MEDIA_PLAY_PAUSE"),
    86: .same(proto: "KEYCODE_MEDIA_STOP"),
    87: .same(proto: "KEYCODE_MEDIA_NEXT"),
    88: .same(proto: "KEYCODE_MEDIA_PREVIOUS"),
    89: .same(proto: "KEYCODE_MEDIA_REWIND"),
    90: .same(proto: "KEYCODE_MEDIA_FAST_FORWARD"),
    91: .same(proto: "KEYCODE_MUTE"),
    92: .same(proto: "KEYCODE_PAGE_UP"),
    93: .same(proto: "KEYCODE_PAGE_DOWN"),
    94: .same(proto: "KEYCODE_PICTSYMBOLS"),
    95: .same(proto: "KEYCODE_SWITCH_CHARSET"),
    96: .same(proto: "KEYCODE_BUTTON_A"),
    97: .same(proto: "KEYCODE_BUTTON_B"),
    98: .same(proto: "KEYCODE_BUTTON_C"),
    99: .same(proto: "KEYCODE_BUTTON_X"),
    100: .same(proto: "KEYCODE_BUTTON_Y"),
    101: .same(proto: "KEYCODE_BUTTON_Z"),
    102: .same(proto: "KEYCODE_BUTTON_L1"),
    103: .same(proto: "KEYCODE_BUTTON_R1"),
    104: .same(proto: "KEYCODE_BUTTON_L2"),
    105: .same(proto: "KEYCODE_BUTTON_R2"),
    106: .same(proto: "KEYCODE_BUTTON_THUMBL"),
    107: .same(proto: "KEYCODE_BUTTON_THUMBR"),
    108: .same(proto: "KEYCODE_BUTTON_START"),
    109: .same(proto: "KEYCODE_BUTTON_SELECT"),
    110: .same(proto: "KEYCODE_BUTTON_MODE"),
    111: .same(proto: "KEYCODE_ESCAPE"),
    112: .same(proto: "KEYCODE_FORWARD_DEL"),
    113: .same(proto: "KEYCODE_CTRL_LEFT"),
    114: .same(proto: "KEYCODE_CTRL_RIGHT"),
    115: .same(proto: "KEYCODE_CAPS_LOCK"),
    116: .same(proto: "KEYCODE_SCROLL_LOCK"),
    117: .same(proto: "KEYCODE_META_LEFT"),
    118: .same(proto: "KEYCODE_META_RIGHT"),
    119: .same(proto: "KEYCODE_FUNCTION"),
    120: .same(proto: "KEYCODE_SYSRQ"),
    121: .same(proto: "KEYCODE_BREAK"),
    122: .same(proto: "KEYCODE_MOVE_HOME"),
    123: .same(proto: "KEYCODE_MOVE_END"),
    124: .same(proto: "KEYCODE_INSERT"),
    125: .same(proto: "KEYCODE_FORWARD"),
    126: .same(proto: "KEYCODE_MEDIA_PLAY"),
    127: .same(proto: "KEYCODE_MEDIA_PAUSE"),
    128: .same(proto: "KEYCODE_MEDIA_CLOSE"),
    129: .same(proto: "KEYCODE_MEDIA_EJECT"),
    130: .same(proto: "KEYCODE_MEDIA_RECORD"),
    131: .same(proto: "KEYCODE_F1"),
    132: .same(proto: "KEYCODE_F2"),
    133: .same(proto: "KEYCODE_F3"),
    134: .same(proto: "KEYCODE_F4"),
    135: .same(proto: "KEYCODE_F5"),
    136: .same(proto: "KEYCODE_F6"),
    137: .same(proto: "KEYCODE_F7"),
    138: .same(proto: "KEYCODE_F8"),
    139: .same(proto: "KEYCODE_F9"),
    140: .same(proto: "KEYCODE_F10"),
    141: .same(proto: "KEYCODE_F11"),
    142: .same(proto: "KEYCODE_F12"),
    143: .same(proto: "KEYCODE_NUM_LOCK"),
    144: .same(proto: "KEYCODE_NUMPAD_0"),
    145: .same(proto: "KEYCODE_NUMPAD_1"),
    146: .same(proto: "KEYCODE_NUMPAD_2"),
    147: .same(proto: "KEYCODE_NUMPAD_3"),
    148: .same(proto: "KEYCODE_NUMPAD_4"),
    149: .same(proto: "KEYCODE_NUMPAD_5"),
    150: .same(proto: "KEYCODE_NUMPAD_6"),
    151: .same(proto: "KEYCODE_NUMPAD_7"),
    152: .same(proto: "KEYCODE_NUMPAD_8"),
    153: .same(proto: "KEYCODE_NUMPAD_9"),
    154: .same(proto: "KEYCODE_NUMPAD_DIVIDE"),
    155: .same(proto: "KEYCODE_NUMPAD_MULTIPLY"),
    156: .same(proto: "KEYCODE_NUMPAD_SUBTRACT"),
    157: .same(proto: "KEYCODE_NUMPAD_ADD"),
    158: .same(proto: "KEYCODE_NUMPAD_DOT"),
    159: .same(proto: "KEYCODE_NUMPAD_COMMA"),
    160: .same(proto: "KEYCODE_NUMPAD_ENTER"),
    161: .same(proto: "KEYCODE_NUMPAD_EQUALS"),
    162: .same(proto: "KEYCODE_NUMPAD_LEFT_PAREN"),
    163: .same(proto: "KEYCODE_NUMPAD_RIGHT_PAREN"),
    164: .same(proto: "KEYCODE_VOLUME_MUTE"),
    165: .same(proto: "KEYCODE_INFO"),
    166: .same(proto: "KEYCODE_CHANNEL_UP"),
    167: .same(proto: "KEYCODE_CHANNEL_DOWN"),
    168: .same(proto: "KEYCODE_ZOOM_IN"),
    169: .same(proto: "KEYCODE_ZOOM_OUT"),
    170: .same(proto: "KEYCODE_TV"),
    171: .same(proto: "KEYCODE_WINDOW"),
    172: .same(proto: "KEYCODE_GUIDE"),
    173: .same(proto: "KEYCODE_DVR"),
    174: .same(proto: "KEYCODE_BOOKMARK"),
    175: .same(proto: "KEYCODE_CAPTIONS"),
    176: .same(proto: "KEYCODE_SETTINGS"),
    177: .same(proto: "KEYCODE_TV_POWER"),
    178: .same(proto: "KEYCODE_TV_INPUT"),
    179: .same(proto: "KEYCODE_STB_POWER"),
    180: .same(proto: "KEYCODE_STB_INPUT"),
    181: .same(proto: "KEYCODE_AVR_POWER"),
    182: .same(proto: "KEYCODE_AVR_INPUT"),
    183: .same(proto: "KEYCODE_PROG_RED"),
    184: .same(proto: "KEYCODE_PROG_GREEN"),
    185: .same(proto: "KEYCODE_PROG_YELLOW"),
    186: .same(proto: "KEYCODE_PROG_BLUE"),
    187: .same(proto: "KEYCODE_APP_SWITCH"),
    188: .same(proto: "KEYCODE_BUTTON_1"),
    189: .same(proto: "KEYCODE_BUTTON_2"),
    190: .same(proto: "KEYCODE_BUTTON_3"),
    191: .same(proto: "KEYCODE_BUTTON_4"),
    192: .same(proto: "KEYCODE_BUTTON_5"),
    193: .same(proto: "KEYCODE_BUTTON_6"),
    194: .same(proto: "KEYCODE_BUTTON_7"),
    195: .same(proto: "KEYCODE_BUTTON_8"),
    196: .same(proto: "KEYCODE_BUTTON_9"),
    197: .same(proto: "KEYCODE_BUTTON_10"),
    198: .same(proto: "KEYCODE_BUTTON_11"),
    199: .same(proto: "KEYCODE_BUTTON_12"),
    200: .same(proto: "KEYCODE_BUTTON_13"),
    201: .same(proto: "KEYCODE_BUTTON_14"),
    202: .same(proto: "KEYCODE_BUTTON_15"),
    203: .same(proto: "KEYCODE_BUTTON_16"),
    204: .same(proto: "KEYCODE_LANGUAGE_SWITCH"),
    205: .same(proto: "KEYCODE_MANNER_MODE"),
    206: .same(proto: "KEYCODE_3D_MODE"),
    207: .same(proto: "KEYCODE_CONTACTS"),
    208: .same(proto: "KEYCODE_CALENDAR"),
    209: .same(proto: "KEYCODE_MUSIC"),
    210: .same(proto: "KEYCODE_CALCULATOR"),
    211: .same(proto: "KEYCODE_ZENKAKU_HANKAKU"),
    212: .same(proto: "KEYCODE_EISU"),
    213: .same(proto: "KEYCODE_MUHENKAN"),
    214: .same(proto: "KEYCODE_HENKAN"),
    215: .same(proto: "KEYCODE_KATAKANA_HIRAGANA"),
    216: .same(proto: "KEYCODE_YEN"),
    217: .same(proto: "KEYCODE_RO"),
    218: .same(proto: "KEYCODE_KANA"),
    219: .same(proto: "KEYCODE_ASSIST"),
    220: .same(proto: "KEYCODE_BRIGHTNESS_DOWN"),
    221: .same(proto: "KEYCODE_BRIGHTNESS_UP"),
    222: .same(proto: "KEYCODE_MEDIA_AUDIO_TRACK"),
    223: .same(proto: "KEYCODE_SLEEP"),
    224: .same(proto: "KEYCODE_WAKEUP"),
    225: .same(proto: "KEYCODE_PAIRING"),
    226: .same(proto: "KEYCODE_MEDIA_TOP_MENU"),
    227: .same(proto: "KEYCODE_11"),
    228: .same(proto: "KEYCODE_12"),
    229: .same(proto: "KEYCODE_LAST_CHANNEL"),
    230: .same(proto: "KEYCODE_TV_DATA_SERVICE"),
    231: .same(proto: "KEYCODE_VOICE_ASSIST"),
    232: .same(proto: "KEYCODE_TV_RADIO_SERVICE"),
    233: .same(proto: "KEYCODE_TV_TELETEXT"),
    234: .same(proto: "KEYCODE_TV_NUMBER_ENTRY"),
    235: .same(proto: "KEYCODE_TV_TERRESTRIAL_ANALOG"),
    236: .same(proto: "KEYCODE_TV_TERRESTRIAL_DIGITAL"),
    237: .same(proto: "KEYCODE_TV_SATELLITE"),
    238: .same(proto: "KEYCODE_TV_SATELLITE_BS"),
    239: .same(proto: "KEYCODE_TV_SATELLITE_CS"),
    240: .same(proto: "KEYCODE_TV_SATELLITE_SERVICE"),
    241: .same(proto: "KEYCODE_TV_NETWORK"),
    242: .same(proto: "KEYCODE_TV_ANTENNA_CABLE"),
    243: .same(proto: "KEYCODE_TV_INPUT_HDMI_1"),
    244: .same(proto: "KEYCODE_TV_INPUT_HDMI_2"),
    245: .same(proto: "KEYCODE_TV_INPUT_HDMI_3"),
    246: .same(proto: "KEYCODE_TV_INPUT_HDMI_4"),
    247: .same(proto: "KEYCODE_TV_INPUT_COMPOSITE_1"),
    248: .same(proto: "KEYCODE_TV_INPUT_COMPOSITE_2"),
    249: .same(proto: "KEYCODE_TV_INPUT_COMPONENT_1"),
    250: .same(proto: "KEYCODE_TV_INPUT_COMPONENT_2"),
    251: .same(proto: "KEYCODE_TV_INPUT_VGA_1"),
    252: .same(proto: "KEYCODE_TV_AUDIO_DESCRIPTION"),
    253: .same(proto: "KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP"),
    254: .same(proto: "KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN"),
    255: .same(proto: "KEYCODE_TV_ZOOM_MODE"),
    256: .same(proto: "KEYCODE_TV_CONTENTS_MENU"),
    257: .same(proto: "KEYCODE_TV_MEDIA_CONTEXT_MENU"),
    258: .same(proto: "KEYCODE_TV_TIMER_PROGRAMMING"),
    259: .same(proto: "KEYCODE_HELP"),
    260: .same(proto: "KEYCODE_NAVIGATE_PREVIOUS"),
    261: .same(proto: "KEYCODE_NAVIGATE_NEXT"),
    262: .same(proto: "KEYCODE_NAVIGATE_IN"),
    263: .same(proto: "KEYCODE_NAVIGATE_OUT"),
    264: .same(proto: "KEYCODE_STEM_PRIMARY"),
    265: .same(proto: "KEYCODE_STEM_1"),
    266: .same(proto: "KEYCODE_STEM_2"),
    267: .same(proto: "KEYCODE_STEM_3"),
    268: .same(proto: "KEYCODE_DPAD_UP_LEFT"),
    269: .same(proto: "KEYCODE_DPAD_DOWN_LEFT"),
    270: .same(proto: "KEYCODE_DPAD_UP_RIGHT"),
    271: .same(proto: "KEYCODE_DPAD_DOWN_RIGHT"),
    272: .same(proto: "KEYCODE_MEDIA_SKIP_FORWARD"),
    273: .same(proto: "KEYCODE_MEDIA_SKIP_BACKWARD"),
    274: .same(proto: "KEYCODE_MEDIA_STEP_FORWARD"),
    275: .same(proto: "KEYCODE_MEDIA_STEP_BACKWARD"),
    276: .same(proto: "KEYCODE_SOFT_SLEEP"),
    277: .same(proto: "KEYCODE_CUT"),
    278: .same(proto: "KEYCODE_COPY"),
    279: .same(proto: "KEYCODE_PASTE"),
    280: .same(proto: "KEYCODE_SYSTEM_NAVIGATION_UP"),
    281: .same(proto: "KEYCODE_SYSTEM_NAVIGATION_DOWN"),
    282: .same(proto: "KEYCODE_SYSTEM_NAVIGATION_LEFT"),
    283: .same(proto: "KEYCODE_SYSTEM_NAVIGATION_RIGHT"),
    284: .same(proto: "KEYCODE_ALL_APPS"),
    285: .same(proto: "KEYCODE_REFRESH"),
    286: .same(proto: "KEYCODE_THUMBS_UP"),
    287: .same(proto: "KEYCODE_THUMBS_DOWN"),
    288: .same(proto: "KEYCODE_PROFILE_SWITCH"),
    289: .same(proto: "KEYCODE_VIDEO_APP_1"),
    290: .same(proto: "KEYCODE_VIDEO_APP_2"),
    291: .same(proto: "KEYCODE_VIDEO_APP_3"),
    292: .same(proto: "KEYCODE_VIDEO_APP_4"),
    293: .same(proto: "KEYCODE_VIDEO_APP_5"),
    294: .same(proto: "KEYCODE_VIDEO_APP_6"),
    295: .same(proto: "KEYCODE_VIDEO_APP_7"),
    296: .same(proto: "KEYCODE_VIDEO_APP_8"),
    297: .same(proto: "KEYCODE_FEATURED_APP_1"),
    298: .same(proto: "KEYCODE_FEATURED_APP_2"),
    299: .same(proto: "KEYCODE_FEATURED_APP_3"),
    300: .same(proto: "KEYCODE_FEATURED_APP_4"),
    301: .same(proto: "KEYCODE_DEMO_APP_1"),
    302: .same(proto: "KEYCODE_DEMO_APP_2"),
    303: .same(proto: "KEYCODE_DEMO_APP_3"),
    304: .same(proto: "KEYCODE_DEMO_APP_4"),
  ]
}

extension Remote_RemoteDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DIRECTION"),
    1: .same(proto: "START_LONG"),
    2: .same(proto: "END_LONG"),
    3: .same(proto: "SHORT"),
  ]
}

extension Remote_RemoteAppLinkLaunchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteAppLinkLaunchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appLink.isEmpty {
      try visitor.visitSingularStringField(value: self.appLink, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteAppLinkLaunchRequest, rhs: Remote_RemoteAppLinkLaunchRequest) -> Bool {
    if lhs.appLink != rhs.appLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteResetPreferredAudioDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteResetPreferredAudioDevice"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteResetPreferredAudioDevice, rhs: Remote_RemoteResetPreferredAudioDevice) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteSetPreferredAudioDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteSetPreferredAudioDevice"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteSetPreferredAudioDevice, rhs: Remote_RemoteSetPreferredAudioDevice) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteAdjustVolumeLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteAdjustVolumeLevel"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteAdjustVolumeLevel, rhs: Remote_RemoteAdjustVolumeLevel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteSetVolumeLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteSetVolumeLevel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown1"),
    2: .same(proto: "unknown2"),
    3: .standard(proto: "player_model"),
    4: .same(proto: "unknown4"),
    5: .same(proto: "unknown5"),
    6: .standard(proto: "volume_max"),
    7: .standard(proto: "volume_level"),
    8: .standard(proto: "volume_muted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.unknown1) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.unknown2) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.playerModel) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.unknown4) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.unknown5) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.volumeMax) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.volumeLevel) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.volumeMuted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unknown1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.unknown1, fieldNumber: 1)
    }
    if self.unknown2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.unknown2, fieldNumber: 2)
    }
    if !self.playerModel.isEmpty {
      try visitor.visitSingularStringField(value: self.playerModel, fieldNumber: 3)
    }
    if self.unknown4 != 0 {
      try visitor.visitSingularUInt32Field(value: self.unknown4, fieldNumber: 4)
    }
    if self.unknown5 != 0 {
      try visitor.visitSingularUInt32Field(value: self.unknown5, fieldNumber: 5)
    }
    if self.volumeMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.volumeMax, fieldNumber: 6)
    }
    if self.volumeLevel != 0 {
      try visitor.visitSingularUInt32Field(value: self.volumeLevel, fieldNumber: 7)
    }
    if self.volumeMuted != false {
      try visitor.visitSingularBoolField(value: self.volumeMuted, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteSetVolumeLevel, rhs: Remote_RemoteSetVolumeLevel) -> Bool {
    if lhs.unknown1 != rhs.unknown1 {return false}
    if lhs.unknown2 != rhs.unknown2 {return false}
    if lhs.playerModel != rhs.playerModel {return false}
    if lhs.unknown4 != rhs.unknown4 {return false}
    if lhs.unknown5 != rhs.unknown5 {return false}
    if lhs.volumeMax != rhs.volumeMax {return false}
    if lhs.volumeLevel != rhs.volumeLevel {return false}
    if lhs.volumeMuted != rhs.volumeMuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "started"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteStart, rhs: Remote_RemoteStart) -> Bool {
    if lhs.started != rhs.started {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteVoiceEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteVoiceEnd"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteVoiceEnd, rhs: Remote_RemoteVoiceEnd) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteVoicePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteVoicePayload"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteVoicePayload, rhs: Remote_RemoteVoicePayload) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteVoiceBegin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteVoiceBegin"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteVoiceBegin, rhs: Remote_RemoteVoiceBegin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteTextFieldStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteTextFieldStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "counter_field"),
    2: .same(proto: "value"),
    3: .same(proto: "start"),
    4: .same(proto: "end"),
    5: .same(proto: "int5"),
    6: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.counterField) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.start) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.end) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.int5) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counterField != 0 {
      try visitor.visitSingularInt32Field(value: self.counterField, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 3)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 4)
    }
    if self.int5 != 0 {
      try visitor.visitSingularInt32Field(value: self.int5, fieldNumber: 5)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteTextFieldStatus, rhs: Remote_RemoteTextFieldStatus) -> Bool {
    if lhs.counterField != rhs.counterField {return false}
    if lhs.value != rhs.value {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.int5 != rhs.int5 {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteImeShowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteImeShowRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "remote_text_field_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._remoteTextFieldStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._remoteTextFieldStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteImeShowRequest, rhs: Remote_RemoteImeShowRequest) -> Bool {
    if lhs._remoteTextFieldStatus != rhs._remoteTextFieldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteEditInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteEditInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "insert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.insert) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.insert != 0 {
      try visitor.visitSingularInt32Field(value: self.insert, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteEditInfo, rhs: Remote_RemoteEditInfo) -> Bool {
    if lhs.insert != rhs.insert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteImeBatchEdit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteImeBatchEdit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ime_counter"),
    2: .standard(proto: "field_counter"),
    3: .standard(proto: "edit_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.imeCounter) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.fieldCounter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._editInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.imeCounter != 0 {
      try visitor.visitSingularInt32Field(value: self.imeCounter, fieldNumber: 1)
    }
    if self.fieldCounter != 0 {
      try visitor.visitSingularInt32Field(value: self.fieldCounter, fieldNumber: 2)
    }
    try { if let v = self._editInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteImeBatchEdit, rhs: Remote_RemoteImeBatchEdit) -> Bool {
    if lhs.imeCounter != rhs.imeCounter {return false}
    if lhs.fieldCounter != rhs.fieldCounter {return false}
    if lhs._editInfo != rhs._editInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteAppInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteAppInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "int2"),
    3: .same(proto: "int3"),
    4: .same(proto: "int4"),
    7: .same(proto: "int7"),
    8: .same(proto: "int8"),
    10: .same(proto: "label"),
    12: .standard(proto: "app_package"),
    13: .same(proto: "int13"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.int2) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.int3) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.int4) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.int7) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.int8) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.appPackage) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.int13) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularInt32Field(value: self.counter, fieldNumber: 1)
    }
    if self.int2 != 0 {
      try visitor.visitSingularInt32Field(value: self.int2, fieldNumber: 2)
    }
    if self.int3 != 0 {
      try visitor.visitSingularInt32Field(value: self.int3, fieldNumber: 3)
    }
    if !self.int4.isEmpty {
      try visitor.visitSingularStringField(value: self.int4, fieldNumber: 4)
    }
    if self.int7 != 0 {
      try visitor.visitSingularInt32Field(value: self.int7, fieldNumber: 7)
    }
    if self.int8 != 0 {
      try visitor.visitSingularInt32Field(value: self.int8, fieldNumber: 8)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 10)
    }
    if !self.appPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.appPackage, fieldNumber: 12)
    }
    if self.int13 != 0 {
      try visitor.visitSingularInt32Field(value: self.int13, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteAppInfo, rhs: Remote_RemoteAppInfo) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.int2 != rhs.int2 {return false}
    if lhs.int3 != rhs.int3 {return false}
    if lhs.int4 != rhs.int4 {return false}
    if lhs.int7 != rhs.int7 {return false}
    if lhs.int8 != rhs.int8 {return false}
    if lhs.label != rhs.label {return false}
    if lhs.appPackage != rhs.appPackage {return false}
    if lhs.int13 != rhs.int13 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteImeKeyInject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteImeKeyInject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_info"),
    2: .standard(proto: "text_field_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._appInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._textFieldStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._appInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textFieldStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteImeKeyInject, rhs: Remote_RemoteImeKeyInject) -> Bool {
    if lhs._appInfo != rhs._appInfo {return false}
    if lhs._textFieldStatus != rhs._textFieldStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteKeyInject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteKeyInject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_code"),
    2: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.keyCode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyCode != .keycodeUnknown {
      try visitor.visitSingularEnumField(value: self.keyCode, fieldNumber: 1)
    }
    if self.direction != .unknownDirection {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteKeyInject, rhs: Remote_RemoteKeyInject) -> Bool {
    if lhs.keyCode != rhs.keyCode {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemotePingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemotePingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.val1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.val1 != 0 {
      try visitor.visitSingularInt32Field(value: self.val1, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemotePingResponse, rhs: Remote_RemotePingResponse) -> Bool {
    if lhs.val1 != rhs.val1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemotePingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemotePingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val1"),
    2: .same(proto: "val2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.val1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.val2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.val1 != 0 {
      try visitor.visitSingularInt32Field(value: self.val1, fieldNumber: 1)
    }
    if self.val2 != 0 {
      try visitor.visitSingularInt32Field(value: self.val2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemotePingRequest, rhs: Remote_RemotePingRequest) -> Bool {
    if lhs.val1 != rhs.val1 {return false}
    if lhs.val2 != rhs.val2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteSetActive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteSetActive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.active) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.active != 0 {
      try visitor.visitSingularInt32Field(value: self.active, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteSetActive, rhs: Remote_RemoteSetActive) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "vendor"),
    3: .same(proto: "unknown1"),
    4: .same(proto: "unknown2"),
    5: .standard(proto: "package_name"),
    6: .standard(proto: "app_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vendor) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unknown1) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unknown2) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    if !self.vendor.isEmpty {
      try visitor.visitSingularStringField(value: self.vendor, fieldNumber: 2)
    }
    if self.unknown1 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknown1, fieldNumber: 3)
    }
    if !self.unknown2.isEmpty {
      try visitor.visitSingularStringField(value: self.unknown2, fieldNumber: 4)
    }
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 5)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteDeviceInfo, rhs: Remote_RemoteDeviceInfo) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.vendor != rhs.vendor {return false}
    if lhs.unknown1 != rhs.unknown1 {return false}
    if lhs.unknown2 != rhs.unknown2 {return false}
    if lhs.packageName != rhs.packageName {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code1"),
    2: .standard(proto: "device_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code1) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code1 != 0 {
      try visitor.visitSingularInt32Field(value: self.code1, fieldNumber: 1)
    }
    try { if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteConfigure, rhs: Remote_RemoteConfigure) -> Bool {
    if lhs.code1 != rhs.code1 {return false}
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _value: Bool = false
    var _message: Remote_RemoteMessage? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._value) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._value != false {
        try visitor.visitSingularBoolField(value: _storage._value, fieldNumber: 1)
      }
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteError, rhs: Remote_RemoteError) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Remote_RemoteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remote_configure"),
    2: .standard(proto: "remote_set_active"),
    3: .standard(proto: "remote_error"),
    8: .standard(proto: "remote_ping_request"),
    9: .standard(proto: "remote_ping_response"),
    10: .standard(proto: "remote_key_inject"),
    20: .standard(proto: "remote_ime_key_inject"),
    21: .standard(proto: "remote_ime_batch_edit"),
    22: .standard(proto: "remote_ime_show_request"),
    30: .standard(proto: "remote_voice_begin"),
    31: .standard(proto: "remote_voice_payload"),
    32: .standard(proto: "remote_voice_end"),
    40: .standard(proto: "remote_start"),
    50: .standard(proto: "remote_set_volume_level"),
    51: .standard(proto: "remote_adjust_volume_level"),
    60: .standard(proto: "remote_set_preferred_audio_device"),
    61: .standard(proto: "remote_reset_preferred_audio_device"),
    90: .standard(proto: "remote_app_link_launch_request"),
  ]

  fileprivate class _StorageClass {
    var _remoteConfigure: Remote_RemoteConfigure? = nil
    var _remoteSetActive: Remote_RemoteSetActive? = nil
    var _remoteError: Remote_RemoteError? = nil
    var _remotePingRequest: Remote_RemotePingRequest? = nil
    var _remotePingResponse: Remote_RemotePingResponse? = nil
    var _remoteKeyInject: Remote_RemoteKeyInject? = nil
    var _remoteImeKeyInject: Remote_RemoteImeKeyInject? = nil
    var _remoteImeBatchEdit: Remote_RemoteImeBatchEdit? = nil
    var _remoteImeShowRequest: Remote_RemoteImeShowRequest? = nil
    var _remoteVoiceBegin: Remote_RemoteVoiceBegin? = nil
    var _remoteVoicePayload: Remote_RemoteVoicePayload? = nil
    var _remoteVoiceEnd: Remote_RemoteVoiceEnd? = nil
    var _remoteStart: Remote_RemoteStart? = nil
    var _remoteSetVolumeLevel: Remote_RemoteSetVolumeLevel? = nil
    var _remoteAdjustVolumeLevel: Remote_RemoteAdjustVolumeLevel? = nil
    var _remoteSetPreferredAudioDevice: Remote_RemoteSetPreferredAudioDevice? = nil
    var _remoteResetPreferredAudioDevice: Remote_RemoteResetPreferredAudioDevice? = nil
    var _remoteAppLinkLaunchRequest: Remote_RemoteAppLinkLaunchRequest? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _remoteConfigure = source._remoteConfigure
      _remoteSetActive = source._remoteSetActive
      _remoteError = source._remoteError
      _remotePingRequest = source._remotePingRequest
      _remotePingResponse = source._remotePingResponse
      _remoteKeyInject = source._remoteKeyInject
      _remoteImeKeyInject = source._remoteImeKeyInject
      _remoteImeBatchEdit = source._remoteImeBatchEdit
      _remoteImeShowRequest = source._remoteImeShowRequest
      _remoteVoiceBegin = source._remoteVoiceBegin
      _remoteVoicePayload = source._remoteVoicePayload
      _remoteVoiceEnd = source._remoteVoiceEnd
      _remoteStart = source._remoteStart
      _remoteSetVolumeLevel = source._remoteSetVolumeLevel
      _remoteAdjustVolumeLevel = source._remoteAdjustVolumeLevel
      _remoteSetPreferredAudioDevice = source._remoteSetPreferredAudioDevice
      _remoteResetPreferredAudioDevice = source._remoteResetPreferredAudioDevice
      _remoteAppLinkLaunchRequest = source._remoteAppLinkLaunchRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._remoteConfigure) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._remoteSetActive) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._remoteError) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._remotePingRequest) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._remotePingResponse) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._remoteKeyInject) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._remoteImeKeyInject) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._remoteImeBatchEdit) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._remoteImeShowRequest) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._remoteVoiceBegin) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._remoteVoicePayload) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._remoteVoiceEnd) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._remoteStart) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._remoteSetVolumeLevel) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._remoteAdjustVolumeLevel) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._remoteSetPreferredAudioDevice) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._remoteResetPreferredAudioDevice) }()
        case 90: try { try decoder.decodeSingularMessageField(value: &_storage._remoteAppLinkLaunchRequest) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._remoteConfigure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._remoteSetActive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._remoteError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._remotePingRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._remotePingResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._remoteKeyInject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._remoteImeKeyInject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._remoteImeBatchEdit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._remoteImeShowRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._remoteVoiceBegin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._remoteVoicePayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._remoteVoiceEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._remoteStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._remoteSetVolumeLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._remoteAdjustVolumeLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._remoteSetPreferredAudioDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._remoteResetPreferredAudioDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._remoteAppLinkLaunchRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Remote_RemoteMessage, rhs: Remote_RemoteMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._remoteConfigure != rhs_storage._remoteConfigure {return false}
        if _storage._remoteSetActive != rhs_storage._remoteSetActive {return false}
        if _storage._remoteError != rhs_storage._remoteError {return false}
        if _storage._remotePingRequest != rhs_storage._remotePingRequest {return false}
        if _storage._remotePingResponse != rhs_storage._remotePingResponse {return false}
        if _storage._remoteKeyInject != rhs_storage._remoteKeyInject {return false}
        if _storage._remoteImeKeyInject != rhs_storage._remoteImeKeyInject {return false}
        if _storage._remoteImeBatchEdit != rhs_storage._remoteImeBatchEdit {return false}
        if _storage._remoteImeShowRequest != rhs_storage._remoteImeShowRequest {return false}
        if _storage._remoteVoiceBegin != rhs_storage._remoteVoiceBegin {return false}
        if _storage._remoteVoicePayload != rhs_storage._remoteVoicePayload {return false}
        if _storage._remoteVoiceEnd != rhs_storage._remoteVoiceEnd {return false}
        if _storage._remoteStart != rhs_storage._remoteStart {return false}
        if _storage._remoteSetVolumeLevel != rhs_storage._remoteSetVolumeLevel {return false}
        if _storage._remoteAdjustVolumeLevel != rhs_storage._remoteAdjustVolumeLevel {return false}
        if _storage._remoteSetPreferredAudioDevice != rhs_storage._remoteSetPreferredAudioDevice {return false}
        if _storage._remoteResetPreferredAudioDevice != rhs_storage._remoteResetPreferredAudioDevice {return false}
        if _storage._remoteAppLinkLaunchRequest != rhs_storage._remoteAppLinkLaunchRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
